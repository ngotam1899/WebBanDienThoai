"use strict";

exports.__esModule = true;
exports["default"] = exports.Context = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var Context = _react["default"].createContext({}); //component - CoreUI / CSidebar


exports.Context = Context;

var CSidebar = function CSidebar(props) {
  var children = props.children,
      className = props.className,
      innerRef = props.innerRef,
      breakpoint = props.breakpoint,
      show = props.show,
      fixed = props.fixed,
      unfoldable = props.unfoldable,
      minimize = props.minimize,
      size = props.size,
      hideOnMobileClick = props.hideOnMobileClick,
      aside = props.aside,
      colorScheme = props.colorScheme,
      overlaid = props.overlaid,
      dropdownMode = props.dropdownMode,
      onShowChange = props.onShowChange,
      onMinimizeChange = props.onMinimizeChange,
      attributes = _objectWithoutPropertiesLoose(props, ["children", "className", "innerRef", "breakpoint", "show", "fixed", "unfoldable", "minimize", "size", "hideOnMobileClick", "aside", "colorScheme", "overlaid", "dropdownMode", "onShowChange", "onMinimizeChange"]);

  var key = (0, _react.useState)(Math.random().toString(36).substr(2))[0];

  var _useState = (0, _react.useState)(show),
      isOpen = _useState[0],
      setIsOpen = _useState[1];

  var _useState2 = (0, _react.useState)(),
      openDropdown = _useState2[0],
      setOpenDropdown = _useState2[1];

  var node = (0, _react.useRef)({}).current;

  var reference = function reference(r) {
    node.current = r;
    innerRef && innerRef(r);
  };

  var _useState3 = (0, _react.useState)(minimize),
      minimized = _useState3[0],
      setIsMinimized = _useState3[1];

  (0, _react.useMemo)(function () {
    setIsMinimized(minimize);
  }, [minimize]);

  var toggleMinimize = function toggleMinimize() {
    setIsMinimized(!minimized);
    onMinimizeChange && onMinimizeChange(minimized);
  }; // compData.nextRender = true


  (0, _react.useMemo)(function () {
    setIsOpen(show);
  }, [show]);
  (0, _react.useEffect)(function () {
    isOpen === true ? createBackdrop() : removeBackdrop();
    return function () {
      return removeBackdrop();
    };
  }, [isOpen]); //methods

  var sidebarCloseListener = function sidebarCloseListener(e) {
    if (document.getElementById(key + 'backdrop') && !node.current.contains(e.target)) {
      closeSidebar();
    }
  };

  var createBackdrop = function createBackdrop() {
    var backdrop = document.createElement('div');

    if (overlaid) {
      document.addEventListener('click', sidebarCloseListener, true);
    } else {
      backdrop.addEventListener('click', closeSidebar);
    }

    backdrop.className = 'c-sidebar-backdrop c-show';
    backdrop.id = key + 'backdrop';
    document.body.appendChild(backdrop);
  };

  var removeBackdrop = function removeBackdrop() {
    var backdrop = document.getElementById(key + 'backdrop');

    if (backdrop) {
      document.removeEventListener('click', sidebarCloseListener);
      backdrop.removeEventListener('click', closeSidebar);
      document.body.removeChild(backdrop);
    }
  };

  var closeSidebar = function closeSidebar() {
    onShowChange && onShowChange(overlaid ? false : 'responsive');
    setIsOpen(overlaid ? false : 'responsive');
  };

  var isOnMobile = function isOnMobile() {
    return Boolean(getComputedStyle(node.current).getPropertyValue('--is-mobile'));
  };

  var onSidebarClick = function onSidebarClick(e) {
    var hiddingElementClicked = e.target.className.includes && e.target.className.includes('c-sidebar-nav-link');

    if (hiddingElementClicked && hideOnMobileClick && isOnMobile()) {
      closeSidebar();
    }
  }; // render


  var haveResponsiveClass = breakpoint && isOpen === 'responsive';
  var classes = (0, _classnames["default"])(className, 'c-sidebar', colorScheme ? "c-sidebar-" + colorScheme : null, isOpen === true ? 'c-sidebar-show' : null, haveResponsiveClass ? "c-sidebar-" + breakpoint + "-show" : null, fixed && !overlaid ? 'c-sidebar-fixed' : null, aside ? 'c-sidebar-right' : null, minimized && !unfoldable ? 'c-sidebar-minimized' : null, minimized && unfoldable ? 'c-sidebar-unfoldable' : null, overlaid ? 'c-sidebar-overlaid' : null, size ? "c-sidebar-" + size : null);
  return /*#__PURE__*/_react["default"].createElement(Context.Provider, {
    value: {
      dropdownMode: dropdownMode,
      scrollbarExist: !minimized || unfoldable,
      toggleMinimize: toggleMinimize,
      openDropdown: openDropdown,
      setOpenDropdown: setOpenDropdown
    }
  }, /*#__PURE__*/_react["default"].createElement("div", _extends({}, attributes, {
    className: classes,
    ref: reference,
    onClick: onSidebarClick
  }), children));
};

CSidebar.propTypes = process.env.NODE_ENV !== "production" ? {
  children: _propTypes["default"].node,
  className: _propTypes["default"].string,
  //
  innerRef: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].func, _propTypes["default"].string]),
  fixed: _propTypes["default"].bool,
  unfoldable: _propTypes["default"].bool,
  overlaid: _propTypes["default"].bool,
  breakpoint: _propTypes["default"].oneOf([false, '', 'sm', 'md', 'lg', 'xl']),
  minimize: _propTypes["default"].bool,
  show: _propTypes["default"].oneOf(['', true, false, 'responsive']),
  size: _propTypes["default"].oneOf(['', 'sm', 'lg', 'xl']),
  hideOnMobileClick: _propTypes["default"].bool,
  aside: _propTypes["default"].bool,
  colorScheme: _propTypes["default"].string,
  dropdownMode: _propTypes["default"].oneOf(['', 'openActive', 'close', 'closeInactive', 'noAction']),
  onShowChange: _propTypes["default"].func,
  onMinimizeChange: _propTypes["default"].func
} : {};
CSidebar.defaultProps = {
  fixed: true,
  breakpoint: 'lg',
  show: 'responsive',
  hideOnMobileClick: true,
  colorScheme: 'dark'
};
var _default = CSidebar;
exports["default"] = _default;